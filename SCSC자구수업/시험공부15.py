# Hash Table


# Ch 6. Hash Table


# 이진탐색트리에서 최대성능은 O(log n) 이었다.

# 만약, 데이터의 키로 1차원 배열의 인덱스를 사용하면 O(1)도 가능하다.

# 이는 공간으로 시간을 사는 개념이다.


# 문제는 배열의 공백이 많아 메모리 낭비가 심하다.

# 다른 방법으로 키를 직접 쓰지 말고, 키를 특정함수(예: 나머지 함수)에 넣고 결과를 인덱스로 사용해 공백을 줄이는 방법을 사용할 수 있다.


# 이 경우, 메모리 낭비는 줄일 수 있지만, 서로 다른 키들이 동일한 해시값을 가질 때 충돌문제가 발생한다.

# 가장 이상적인 해시함수는 키들을 균등하게(Uniformly) 해시테이블의 인덱스로 변환하는 함수다.

# 널리 사용되는 해시함수는 나눗셈(Division) 함수다. 나눗셈 함수는 키를 M으로 나눈 뒤, 그 나머지를 해시값으로 사용한다.

# h(key) = key % M이고, 따라서 해시테이블의 인덱스는 0에서 M-1이 됨

# M은 일반적으로 key 개수의 3배 정도이며 소수(prime number)를 사용한다.

# 충돌 처리
# 충돌이 일어날 경우, 처리하는 방법으로 개방주소방식과 폐쇄 주소방식이 있다.
# 개방 주소방식과 폐쇄 주소방식의 차이는 충돌이 일어날 경우, 충돌지점에서 다른 주소까지 개방해서 원소를 삽입할 수 있는 경우가 개방주소방식이고, 폐쇄주소방식은 충돌이 일어난 주소에서 문제를 해결하는 방식이다.
# 개방주소방식
# 개방주소방식은 충돌이 일어난 위치 다음 인덱스로 이동하면서 처음나오는 빈 주소에 저장하는 방식이다.

# 메모리의 크기가 M개이므로 (h(key)+j) % M 으로 위치를 이동한다. 즉, M번째까지 가면 다시 0번째가 됨을 의미한다.

# x = [25, 37, 18, 55, 22, 35, 50, 63]을 해시 테이블에 저장해보자.

# Linear Probing: 충돌시, 해당 인덱스에서 빈곳을 찾아 순차적으로 이동하다가 빈곳이 나오면 입력한다. (h(key)+j) % M

# Quad Probing: 충돌시, 해당 인덱스에서 빈곳을 찾을 때, 순차적으로 이동하는 것이 아니고 점프간격을 제곱으로 이동하여 삽입여부를 결정한다. (h(key)+j**2) % M

# Random Probing: 충돌시, 해당 인덱스에서 빈곳을 찾을 때, 그 다음 위치를 랜덤하게 이동하여 삽입 여부를 결정한다.
# 단, 탐색을 위해서는 난수의 seed를 지정해야 한다. (h(key)+randInt) % M
# seed를 시간으로 줄 경우, 찾을 수 없으므로 반드시 일정한 seed를 줘야 한다.

# Linear Probing의 경우, 인덱스가 한쪽으로 뭉치는 현상이 발생하는데 이를 방지하고자 Quad, Random 등의 방법을 사용한다.

# Quad Probing의 경우에는 다른쪽에서 뭉침현상이 나타나고 Random Probing은 무작위 위치에서 뭉침현상이 발생한다.


